# -*- coding: utf-8 -*-
"""rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1126qQKei2ZlV6zDe1OH1u0MElz3V6l3l

# Sistem Rekomendasi Game Steam

Proyek ini mengimplementasikan sistem rekomendasi game berbasis content-based filtering menggunakan data dari platform Steam. Sistem akan merekomendasikan game berdasarkan kemiripan genre menggunakan TF-IDF dan Cosine Similarity.

Pada proyek ini, kita akan:
1. Menganalisis dataset Steam yang berisi informasi game
2. Melakukan preprocessing dan persiapan data
3. Membuat model rekomendasi berbasis konten
4. Mengevaluasi hasil rekomendasi

## Membuat dataset

## Dataset

Dataset yang digunakan berasal dari [Steam Store Games (Clean dataset)](https://www.kaggle.com/datasets/nikdavis/steam-store-games) yang berisi informasi lengkap tentang game-game di Steam. Dataset ini terdiri dari beberapa file CSV:

- steam.csv: informasi dasar game (appid, nama, dll.)
- steam_description_data.csv: deskripsi game
- steam_media_data.csv: link media
- steam_requirements_data.csv: spesifikasi
- steam_support_info.csv: info dukungan
- steamspy_tag_data.csv: tag komunitas
"""

# versi colab

# from google.colab import files
# files.upload()
# !mkdir -p ~/.kaggle
# !cp kaggle.json ~/.kaggle/
# !chmod 600 ~/.kaggle/kaggle.json
# !kaggle datasets download -d nikdavis/steam-store-games
# !unzip steam-store-games.zip

# Colab Saya Crash, Saya ambil pendekatan memakai vs code agar tetap bisa lanjut, berikut caranya (comand prompt untuk download dari kaggle):

# mkdir %USERPROFILE%\.kaggle
# copy kaggle.json %USERPROFILE%\.kaggle\
# kaggle datasets download -d nikdavis/steam-store-games
# tar -xf steam-store-games.zip

import pandas as pd

# Load semua file CSV dari dataset Steam
# Dataset ini terdiri dari beberapa file yang saling terkait:
# - steam.csv: Data utama game (27,075 baris)
# - steam_description_data.csv: Deskripsi game
# - steam_media_data.csv: Data media game
# - steam_requirements_data.csv: Spesifikasi game
# - steam_support_info.csv: Informasi dukungan
# - steamspy_tag_data.csv: Data tag dari komunitas

steam = pd.read_csv('steam.csv')
desc = pd.read_csv('steam_description_data.csv')
media = pd.read_csv('steam_media_data.csv')
req = pd.read_csv('steam_requirements_data.csv')
support = pd.read_csv('steam_support_info.csv')
tags = pd.read_csv('steamspy_tag_data.csv')

# Analisis jumlah data unik per file CSV
print("Jumlah game utama (steam.csv):", steam['appid'].nunique())
print("Jumlah deskripsi game (steam_description_data.csv):", desc['steam_appid'].nunique())
print("Jumlah media game (steam_media_data.csv):", media['steam_appid'].nunique())
print("Jumlah spesifikasi game (steam_requirements_data.csv):", req['steam_appid'].nunique())
print("Jumlah informasi support game (steam_support_info.csv):", support['steam_appid'].nunique())
print("Jumlah data tag steamspy (steamspy_tag_data.csv):", tags['appid'].nunique())

"""## Analisis Dataset

Pada bagian ini, kita akan menganalisis setiap file CSV untuk memahami:
1. Jumlah baris dan kolom
2. Tipe data setiap kolom
3. Missing values
4. Memory usage

Hal ini penting untuk menentukan strategi preprocessing yang tepat.

## Eksplorasi Dataset

Pada bagian ini, kita akan melihat informasi detail dari setiap file CSV yang digunakan dalam proyek. Ini membantu kita memahami struktur data, tipe data, dan mengidentifikasi potensi missing values atau masalah data lainnya.
"""

steam.info()

"""### Analisis Dataset Utama (steam.csv)

Dataset utama steam.csv berisi informasi dasar tentang game di Steam. Mari kita lihat struktur datanya:
"""

desc.info()

media.info()

req.info()

support.info()

tags.info()

"""## Data Preprocessing

## Data Preprocessing

Tahap preprocessing data meliputi:
1. Penggabungan dataset berdasarkan appid
2. Penanganan missing values
3. Penghapusan duplikat
4. Normalisasi format data (terutama untuk genre)

Langkah-langkah ini penting untuk memastikan kualitas data yang akan digunakan dalam pembuatan model rekomendasi.

### Menggabungkan dataset dan menghapus duplikat dan mengurut datanya

### Data Integration dan Cleaning

Pada tahap ini, kita akan:
1. Menggabungkan semua dataset berdasarkan appid
2. Menghapus duplikat data
3. Mengurutkan data untuk memudahkan akses
4. Memastikan konsistensi data antar dataset
"""

import numpy as np

# Ambil semua appid (gunakan steam_appid kalau tidak pakai 'appid')
appid_all = np.concatenate((
    steam['appid'].unique(),
    desc['steam_appid'].unique(),
    media['steam_appid'].unique(),
    req['steam_appid'].unique(),
    support['steam_appid'].unique(),
    tags['appid'].unique()
))

# Hapus duplikat dan urutkan
appid_all = np.sort(np.unique(appid_all))

print('Jumlah seluruh data game unik berdasarkan appid:', len(appid_all))

# Gabung steam.csv dengan steamspy_tag_data.csv
merged = pd.merge(steam, tags, on="appid", how="left")

# Gabung deskripsi
merged = pd.merge(merged, desc, left_on="appid", right_on="steam_appid", how="left")

# Gabung support info
merged = pd.merge(merged, support, left_on="appid", right_on="steam_appid", how="left")

# Gabung requirements
merged = pd.merge(merged, req, left_on="appid", right_on="steam_appid", how="left")

# Final check
print("Ukuran final dataframe:", merged.shape)
merged.head()

merged_df = pd.merge(steam, tags, on='appid', how='left')
merged_df = pd.merge(merged_df, desc, left_on='appid', right_on='steam_appid', how='left')

"""## Data Preparation

Pada tahap ini, kita akan melakukan persiapan data melalui beberapa langkah:

1. Integrasi Dataset:
   - Menggabungkan steam.csv dengan steamspy_tag_data.csv
   - Memastikan integritas data dengan penggunaan kunci appid

2. Pembersihan Data:
   - Penanganan missing values
   - Penghapusan duplikat
   - Pengurutan data

3. Preprocessing Genre:
   - Pemisahan string genre
   - Normalisasi format
   - Analisis distribusi genre

4. Persiapan untuk Modeling:
   - Pemilihan fitur yang relevan
   - Pembuatan dataset final

### Mengecek data null dan menghapusnya

### Penanganan Missing Values

Sebelum membuat model, kita perlu menangani missing values dalam dataset. Dari analisis awal, kita menemukan:
- developer: 1,771 nilai kosong
- publisher: 1,650 nilai kosong
- categories: 2,101 nilai kosong
- genres: 1,291 nilai kosong

Karena genre adalah fitur utama untuk sistem rekomendasi kita, baris dengan genre kosong akan dihapus.

### Penanganan Missing Values

Kita akan memeriksa dan menangani nilai null dalam dataset untuk memastikan kualitas data yang akan digunakan dalam pembuatan model. Data yang memiliki nilai null akan dihapus untuk menghindari masalah dalam proses modeling.
"""

merged_df.isnull().sum()

merged_clean = merged_df.dropna()

merged_clean.isnull().sum()

"""### Sorting data berdasarkan id"""

fix_steam = merged_clean.sort_values('appid', ascending=True)
fix_steam.head()

"""### Cek Kategori Genre Unik dan memisahkan genrenya per ;

### Preprocessing Genre

Genre game di Steam disimpan sebagai string dengan format:
"Genre1;Genre2;Genre3"

Kita akan:
1. Memisahkan string menjadi list genre individual
2. Menghapus spasi berlebih
3. Standardisasi format kapitalisasi
4. Menganalisis distribusi genre untuk memahami dataset

### Analisis Genre

Pada bagian ini, kita akan:
1. Mengidentifikasi genre unik dalam dataset
2. Memisahkan genre yang tergabung (dengan separator ';')
3. Menormalisasi format penulisan genre
4. Menganalisis distribusi genre dalam dataset
"""

# Cek genre unik
unique_genres = fix_steam['genres'].unique()
print("Jumlah genre unik:", len(unique_genres))
print("Daftar genre unik:")
for genre in unique_genres:
    print(genre)

# Pisahkan berdasarkan titik koma, dan ubah menjadi list
fix_steam['genre_list'] = fix_steam['genres'].dropna().apply(lambda x: x.split(';'))

# Normalisasi (hapus spasi ekstra, huruf kapital konsisten)
fix_steam['genre_list'] = fix_steam['genre_list'].apply(lambda x: [g.strip().title() for g in x])

from collections import Counter

genre_counter = Counter()
for genres in fix_steam['genre_list'].dropna():
    genre_counter.update(genres)

# Tampilkan 20 genre paling umum
genre_counter.most_common(20)

all_genres_flat = [genre for sublist in fix_steam['genre_list'].dropna() for genre in sublist]
unique_flat_genres = sorted(set(all_genres_flat))
print(unique_flat_genres)

"""## Membuat variabel preparation"""

preparation = fix_steam
preparation.sort_values('appid')

preparation = preparation.drop_duplicates('appid')
preparation

"""## Membuat data frame baru

### Persiapan Dataset Final

Untuk modeling, kita akan membuat DataFrame yang berisi:
1. ID game (appid)
2. Nama game
3. Genre (dalam format yang sudah diproses)

DataFrame ini akan menjadi input untuk proses TF-IDF dan perhitungan similarity.
"""

# Mengambil kolom 'appid', 'name', dan 'genres'
game_id = preparation['appid'].tolist()
game_name = preparation['name'].tolist()
game_genres = preparation['genres'].tolist()

print(len(game_id))
print(len(game_name))
print(len(game_genres))

# Membuat DataFrame seperti dictionary
game_new = pd.DataFrame({
    'id': game_id,
    'game_name': game_name,
    'genre': game_genres
})

# Menampilkan 5 baris pertama
game_new.head()

data = game_new
data.sample(5)

"""## Membuat Model

## Pembuatan Model Content-Based Filtering

Pada tahap ini, kita akan membuat sistem rekomendasi menggunakan pendekatan Content-Based Filtering dengan langkah-langkah:
1. Menggunakan TF-IDF Vectorizer untuk mengubah genre menjadi representasi numerik
2. Menghitung cosine similarity antar game berdasarkan genre
3. Membuat fungsi rekomendasi yang akan mengembalikan top-N game yang memiliki genre serupa
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi vectorizer
tf = TfidfVectorizer()

# Fit data genre
tf.fit(game_new['genre'])

# Lihat fitur yang diekstrak
print("Jumlah fitur unik:", len(tf.get_feature_names_out()))
print("Fitur-fitur:", tf.get_feature_names_out())

"""### TF-IDF Vectorization

Pada tahap ini, kita menggunakan TF-IDF (Term Frequency-Inverse Document Frequency) Vectorizer untuk mengubah data genre menjadi representasi numerik. TF-IDF akan:
1. Mengekstrak fitur unik dari genre game
2. Menghitung bobot setiap genre berdasarkan frekuensi kemunculannya
3. Menghasilkan matriks sparse yang merepresentasikan setiap game dalam ruang vektor genre
"""

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(data['genre'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis masakan
# Baris diisi dengan nama resto

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.game_name
).sample(22, axis=1).sample(10, axis=0)

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""### Cosine Similarity

Setelah mendapatkan representasi vektor dari genre game, kita menghitung kemiripan antar game menggunakan cosine similarity. Metrik ini akan:
1. Mengukur sudut cosinus antara dua vektor game
2. Menghasilkan nilai antara 0 (tidak mirip sama sekali) hingga 1 (identik)
3. Membentuk matriks similarity yang akan digunakan untuk mencari game yang mirip
"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama game
cosine_sim_df = pd.DataFrame(cosine_sim, index=data['game_name'], columns=data['game_name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

def game_recommendations(game_name, similarity_data=cosine_sim_df, items=data[['game_name', 'genre']], k=5):
    """
    Rekomendasi Game berdasarkan kemiripan genre (TF-IDF + Cosine Similarity)

    Parameter:
    ---
    game_name : str
        Nama Game (index dari similarity matrix)

    similarity_data : pd.DataFrame
        Matrix kemiripan (cosine similarity) antar game, dengan game sebagai index dan kolom

    items : pd.DataFrame
        Data yang memuat nama game dan genre-nya

    k : int
        Jumlah rekomendasi yang ingin ditampilkan

    Returns:
    ---
    pd.DataFrame:
        Tabel rekomendasi top-k game terdekat berdasarkan genre
    """

    # Ambil index game berdasarkan similarity tertinggi ke game_name
    index = similarity_data.loc[:, game_name].to_numpy().argpartition(
        range(-1, -k, -1)
    )

    # Ambil nama-nama game dengan similarity tertinggi
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop game yang sedang dicari agar tidak muncul di rekomendasi
    closest = closest.drop(game_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""### Fungsi Rekomendasi

Fungsi `game_recommendations` akan menghasilkan rekomendasi game berdasarkan kemiripan genre. Cara kerjanya:
1. Menerima input nama game yang menjadi acuan
2. Mencari index game-game dengan nilai similarity tertinggi
3. Mengembalikan top-k game yang memiliki genre paling mirip
4. Menghindari merekomendasikan game yang sama dengan input

Parameter fungsi:
- game_name: Nama game yang menjadi acuan
- similarity_data: Matrix cosine similarity antar game
- items: DataFrame berisi informasi game (nama dan genre)
- k: Jumlah rekomendasi yang diinginkan
"""

data[data.game_name.eq('Post Apocalyptic Mayhem')]

"""## Contoh Penggunaan dan Evaluasi

Pada bagian ini, kita akan menguji sistem rekomendasi dengan beberapa contoh game. Untuk setiap game, kita akan:
1. Melihat genre dari game yang dipilih
2. Mendapatkan 5 rekomendasi game dengan genre serupa
3. Mengevaluasi kesesuaian rekomendasi secara kualitatif

Contoh pertama menggunakan game 'Post Apocalyptic Mayhem':
"""

# Mendapatkan rekomendasi restoran yang mirip dengan KFC
game_recommendations('Post Apocalyptic Mayhem')

"""## Kesimpulan

Sistem rekomendasi yang dibuat berhasil memberikan rekomendasi game berdasarkan kemiripan genre. Beberapa poin penting:

1. Sistem menggunakan pendekatan content-based filtering dengan TF-IDF dan cosine similarity
2. Rekomendasi didasarkan pada kemiripan genre antar game
3. Sistem berhasil memberikan rekomendasi yang relevan dan masuk akal
4. Evaluasi dilakukan secara kualitatif dengan memeriksa kesesuaian genre

Peningkatan yang mungkin dilakukan:
1. Menambahkan fitur lain seperti tags dan deskripsi game
2. Mengimplementasikan collaborative filtering
3. Menambahkan filter berdasarkan rating atau popularitas

## Evaluasi Model

Pada bagian ini, kita akan melakukan evaluasi model menggunakan:
1. Metrik kuantitatif: Precision@K
2. Analisis kualitatif hasil rekomendasi

Precision@K mengukur proporsi rekomendasi yang relevan dari K rekomendasi yang diberikan.
"""

def calculate_precision_at_k(input_game, recommendations, k=5):
    """
    Menghitung Precision@K untuk sebuah rekomendasi

    Args:
    input_game (str): Nama game yang menjadi input
    recommendations (pd.DataFrame): Hasil rekomendasi dari fungsi game_recommendations
    k (int): Jumlah rekomendasi yang dievaluasi

    Returns:
    float: Nilai Precision@K
    """
    # Ambil genre game input
    input_genres = set(data[data['game_name'] == input_game]['genre'].iloc[0].split(';'))

    # Hitung rekomendasi yang relevan (memiliki minimal 1 genre yang sama)
    relevant = 0
    for _, row in recommendations.iterrows():
        rec_genres = set(row['genre'].split(';'))
        if len(input_genres.intersection(rec_genres)) > 0:
            relevant += 1

    return relevant / k

# Daftar game untuk evaluasi
sample_games = [
    'Post Apocalyptic Mayhem',
    'Counter-Strike: Global Offensive',
    'Dota 2',
    'Portal 2',
    'Team Fortress 2'
]

# Evaluasi setiap game
for game in sample_games:
    recs = game_recommendations(game)
    precision = calculate_precision_at_k(game, recs)
    print(f"\nGame: {game}")
    print(f"Genre: {data[data['game_name'] == game]['genre'].iloc[0]}")
    print(f"Precision@5: {precision:.2f}")
    print("\nRekomendasi:")
    print(recs[['game_name', 'genre']])

"""### Kesimpulan Evaluasi

1. Evaluasi Kuantitatif:
   - Precision@5 rata-rata diatas 0.9, menunjukkan akurasi rekomendasi yang baik
   - Sistem konsisten memberikan rekomendasi dengan genre yang relevan

2. Evaluasi Kualitatif:
   - Rekomendasi mencakup berbagai game dari developer berbeda
   - Hasil rekomendasi mudah dijelaskan karena berbasis genre
   - Sistem berhasil menemukan game serupa namun kurang populer

3. Potensi Pengembangan:
   - Menambahkan fitur tags untuk rekomendasi lebih spesifik
   - Implementasi filter berdasarkan rating dan popularitas
   - Penambahan pendekatan collaborative filtering
"""